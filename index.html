<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tarot & Tempest Mystery Widget</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito+Sans:ital,wght@0,400;0,600;0,700;0,800;1,400;1,700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              tempest: {
                black: '#000000',
                offblack: '#0b0b0b',
                white: '#ffffff',
                gray: '#8A8A8A',
                red: '#c71717',
              }
            },
            fontFamily: {
              sans: ['"Nunito Sans"', 'sans-serif'],
            },
            animation: {
              'glitch': 'glitch 1s linear infinite',
              'fadeIn': 'fadeIn 0.5s ease-out',
              'slideUp': 'slideUp 0.5s ease-out',
            },
            keyframes: {
              glitch: {
                '2%, 64%': { transform: 'translate(2px,0) skew(0deg)' },
                '4%, 60%': { transform: 'translate(-2px,0) skew(0deg)' },
                '62%': { transform: 'translate(0,0) skew(5deg)' },
              },
              fadeIn: {
                '0%': { opacity: '0' },
                '100%': { opacity: '1' },
              },
              slideUp: {
                '0%': { transform: 'translateY(20px)', opacity: '0' },
                '100%': { transform: 'translateY(0)', opacity: '1' },
              }
            }
          }
        }
      }
    </script>
    <style>
      @layer utilities {
        .perspective-1000 {
          perspective: 1000px;
        }
        .preserve-3d {
          transform-style: preserve-3d;
        }
        .backface-hidden {
          backface-visibility: hidden;
        }
        .rotate-y-180 {
          transform: rotateY(180deg);
        }
      }
      /* Custom scrollbar for the industrial vibe */
      ::-webkit-scrollbar {
        width: 6px;
      }
      ::-webkit-scrollbar-track {
        background: #000000; 
      }
      ::-webkit-scrollbar-thumb {
        background: #333; 
        border-radius: 0px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #c71717; 
      }
      
      .noise-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
        opacity: 0.05;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
      }
      
      .glitch-text {
        position: relative;
        display: inline-block;
      }
      
      .glitch-text::before,
      .glitch-text::after {
        content: attr(data-text);
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
      }
      
      .glitch-text::before {
        left: 2px;
        text-shadow: -1px 0 red;
        clip: rect(44px, 450px, 56px, 0);
        animation: glitch-anim-1 5s infinite linear alternate-reverse;
      }
      
      .glitch-text::after {
        left: -2px;
        text-shadow: -1px 0 blue;
        clip: rect(44px, 450px, 56px, 0);
        animation: glitch-anim-2 5s infinite linear alternate-reverse;
      }
      
      @keyframes glitch-anim-1 {
        0% { clip: rect(30px, 9999px, 10px, 0); }
        100% { clip: rect(80px, 9999px, 90px, 0); }
      }
      
      @keyframes glitch-anim-2 {
        0% { clip: rect(10px, 9999px, 80px, 0); }
        100% { clip: rect(90px, 9999px, 20px, 0); }
      }
    </style>
    <!-- Babel for JSX transformation in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.30.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
  <body class="bg-tempest-black text-white h-screen overflow-hidden antialiased font-sans">
    <div class="noise-bg"></div>
    <div id="root" class="h-full w-full relative z-10"></div>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback } from 'react';
      import { createRoot } from 'react-dom/client';
      import { GoogleGenAI, Type } from "@google/genai";

      // --- TYPES ---
      const WidgetState = {
        IDLE: 'IDLE',
        SHUFFLING: 'SHUFFLING',
        PICKING: 'PICKING',
        REVEALING: 'REVEALING',
        READING: 'READING',
      };

      // --- CONSTANTS ---
      const DISCOUNT_CODE = "TEMPEST10";
      const LOGO_URL = "https://media.sellfy.store/images/eBf0lIHr/SaeE/TT_MINIMAL_LIGHTNING_02_WHITE_ON_ALPHA_STICKER_STYLE.png";

      const TAROT_DECK = [
        { id: 0, name: "The Fool", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/9/90/RWS_Tarot_00_Fool.jpg", keywords: ["Beginnings", "Innocence", "Spontaneity"] },
        { id: 1, name: "The Magician", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/d/de/RWS_Tarot_01_Magician.jpg", keywords: ["Manifestation", "Power", "Action"] },
        { id: 2, name: "The High Priestess", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/8/88/RWS_Tarot_02_High_Priestess.jpg", keywords: ["Intuition", "Mystery", "Subconscious"] },
        { id: 3, name: "The Empress", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/d/d2/RWS_Tarot_03_Empress.jpg", keywords: ["Abundance", "Nature", "Creativity"] },
        { id: 6, name: "The Lovers", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/3/33/RWS_Tarot_06_Lovers.jpg", keywords: ["Love", "Harmony", "Choices"] },
        { id: 9, name: "The Hermit", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/4/4d/RWS_Tarot_09_Hermit.jpg", keywords: ["Soul-searching", "Introspection", "Guidance"] },
        { id: 10, name: "Wheel of Fortune", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/3/3c/RWS_Tarot_10_Wheel_of_Fortune.jpg", keywords: ["Luck", "Karma", "Cycles"] },
        { id: 17, name: "The Star", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/d/db/RWS_Tarot_17_Star.jpg", keywords: ["Hope", "Inspiration", "Serenity"] },
        { id: 19, name: "The Sun", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/1/17/RWS_Tarot_19_Sun.jpg", keywords: ["Joy", "Success", "Vitality"] },
        { id: 21, name: "The World", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/f/ff/RWS_Tarot_21_World.jpg", keywords: ["Completion", "Integration", "Travel"] },
      ];

      // --- SERVICES ---
      const getTarotReading = async (cardName) => {
        if (!process.env.API_KEY) {
          console.error("API Key is missing");
          return {
            reading: "NOISE FLOOR CRITICAL.",
            blessing: "CHECK CONNECTIONS."
          };
        }

        try {
          const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
          
          const prompt = `
            I have drawn the tarot card: ${cardName}.
            
            Your Task: Re-interpret this card as a specific Dubstep/Tearout sound design concept.
            
            CRITICAL RULES:
            1. KEEP IT SHORT. Maximum 15 words for the reading.
            2. STYLE: Abstract, glitchy, system-log style, fragmented sentences.
            3. VOCABULARY: Comb filters, phase cancellation, formants, ott, distortion, transient shaping, resampling, lfo rates.
            4. NO mystical fluff. ONLY audio engineering.
            
            Output Format:
            1. "reading": A very short, punchy description of the sound texture. (e.g., "Hollow formant vowels detecting via comb filter.")
            2. "blessing": A 3-5 word command. (e.g., "CRANK THE DRIVE.")
          `;

          const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: prompt,
            config: {
              systemInstruction: "You are a ruthless audio processing algorithm. Output is minimal, capitalized, and aggressive.",
              responseMimeType: "application/json",
              responseSchema: {
                type: Type.OBJECT,
                properties: {
                  reading: { type: Type.STRING },
                  blessing: { type: Type.STRING },
                }
              }
            },
          });

          const text = response.text;
          if (!text) throw new Error("No text returned");
          
          return JSON.parse(text);

        } catch (error) {
          console.error("Error fetching reading:", error);
          return {
            reading: "SIGNAL CORRUPTED.",
            blessing: "RESET PHASE."
          };
        }
      };

      // --- COMPONENTS ---

      const Card = ({ card, isFlipped, onClick, disabled, style, className }) => {
        return (
          <div 
            className={`relative w-48 h-80 perspective-1000 cursor-pointer ${className}`}
            style={style}
            onClick={() => !disabled && onClick()}
          >
            <div
              className={`w-full h-full relative transition-transform duration-700 preserve-3d shadow-[0_0_15px_rgba(255,255,255,0.1)] ${
                isFlipped ? 'rotate-y-180' : ''
              }`}
            >
              {/* CARD BACK */}
              <div className="absolute w-full h-full backface-hidden border border-white/20 bg-tempest-offblack">
                <div className="w-full h-full flex flex-col items-center justify-center bg-black p-4">
                   <div className="border-2 border-white/10 w-[90%] h-[95%] flex flex-col items-center justify-center relative overflow-hidden">
                      <img 
                        src={LOGO_URL} 
                        alt="Tarot & Tempest" 
                        className="w-32 opacity-80 drop-shadow-[0_0_5px_rgba(255,255,255,0.3)]"
                      />
                      <div className="absolute bottom-4 text-[8px] tracking-[0.4em] text-white/40 uppercase font-bold">
                        MMXXIV
                      </div>
                   </div>
                </div>
              </div>

              {/* CARD FRONT */}
              <div className="absolute w-full h-full backface-hidden rotate-y-180 border border-white bg-black">
                <img 
                  src={card.imageUrl} 
                  alt={card.name} 
                  className="w-full h-full object-cover opacity-80 grayscale contrast-125"
                />
                <div className="absolute bottom-0 left-0 right-0 bg-black/90 border-t border-white/20 p-4 text-center">
                  <h3 className="text-white font-sans text-lg font-bold uppercase tracking-wider">{card.name}</h3>
                </div>
              </div>
            </div>
          </div>
        );
      };

      const ReadingOverlay = ({ card, readingData, onClose }) => {
        const [copied, setCopied] = useState(false);

        const handleCopy = () => {
          navigator.clipboard.writeText(DISCOUNT_CODE);
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        };

        return (
          <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/95 backdrop-blur-md p-4 animate-fadeIn">
            <div className="bg-black border-2 border-white/90 max-w-md w-full p-8 shadow-[0_0_50px_rgba(255,255,255,0.15)] flex flex-col items-center text-center relative overflow-hidden">
              
              <div className="absolute top-0 left-0 w-full h-2 bg-white"></div>
              <div className="absolute bottom-0 right-0 w-16 h-16 border-r-2 border-b-2 border-white/20"></div>
              
              <div className="mb-6 w-full">
                 <h2 className="text-4xl font-black italic text-white mb-2 uppercase tracking-tighter transform -skew-x-12">{card.name}</h2>
                 <div className="w-full h-[2px] bg-white/50"></div>
              </div>

              {readingData ? (
                <div className="space-y-8 animate-slideUp w-full">
                  
                  <div className="text-center">
                      <p className="text-white font-bold text-xl uppercase leading-none tracking-tight glitch-text" data-text={`"${readingData.reading}"`}>
                      "{readingData.reading}"
                      </p>
                  </div>
                  
                  <div className="bg-white text-black p-2 transform -skew-x-6 inline-block">
                    <p className="font-black text-lg uppercase tracking-widest">{readingData.blessing}</p>
                  </div>

                  <div className="mt-4 pt-6 border-t border-dashed border-white/30 w-full">
                    <p className="text-[10px] text-white/60 uppercase tracking-[0.3em] mb-4">Authorization Granted</p>
                    
                    <div className="flex items-stretch justify-center gap-0 mb-2 shadow-[4px_4px_0px_rgba(255,255,255,0.3)]">
                      <div className="bg-white text-black text-2xl px-6 py-3 font-mono font-black tracking-wider border-r-2 border-black">
                        {DISCOUNT_CODE}
                      </div>
                      <button 
                        onClick={handleCopy}
                        className="bg-tempest-red hover:brightness-125 text-white font-bold py-3 px-6 transition-all uppercase text-sm tracking-wide"
                      >
                        {copied ? 'COPIED' : 'COPY'}
                      </button>
                    </div>
                    
                    <p className="text-white font-bold italic uppercase tracking-widest text-xs mt-6 animate-pulse">
                      // ENJOY YOUR CODE //
                    </p>
                  </div>
                  
                  <button 
                    onClick={onClose}
                    className="mt-6 w-full py-2 border border-white/20 text-white/50 hover:text-white hover:border-white hover:bg-white/5 transition-all uppercase text-xs tracking-[0.2em] font-bold"
                  >
                    RE-INITIALIZE SYSTEM
                  </button>
                </div>
              ) : (
                <div className="flex flex-col items-center justify-center py-12 space-y-6">
                   <div className="w-16 h-16 border-t-4 border-l-4 border-white animate-spin rounded-none"></div>
                   <p className="text-white font-mono text-xs animate-pulse uppercase tracking-widest">Synthesizing...</p>
                </div>
              )}

              <button 
                onClick={onClose}
                className="absolute top-4 right-4 text-white/50 hover:text-white transition-colors hover:rotate-90 duration-300"
              >
                <svg className="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="square" strokeLinejoin="miter" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>
          </div>
        );
      };

      const MysteryWidget = () => {
        const [gameState, setGameState] = useState(WidgetState.IDLE);
        const [deck, setDeck] = useState(TAROT_DECK);
        const [selectedCardId, setSelectedCardId] = useState(null);
        const [readingData, setReadingData] = useState(null);

        useEffect(() => {
          if (gameState === WidgetState.IDLE) {
            const timer = setTimeout(() => {
              setGameState(WidgetState.SHUFFLING);
            }, 1200);
            return () => clearTimeout(timer);
          }
        }, [gameState]);

        useEffect(() => {
          if (gameState === WidgetState.SHUFFLING) {
            const interval = setInterval(() => {
              setDeck(prev => [...prev].sort(() => Math.random() - 0.5));
            }, 150);

            const endShuffle = setTimeout(() => {
              clearInterval(interval);
              setGameState(WidgetState.PICKING);
            }, 2000);

            return () => {
              clearInterval(interval);
              clearTimeout(endShuffle);
            };
          }
        }, [gameState]);

        const handleCardClick = useCallback(async (card) => {
          if (gameState !== WidgetState.PICKING) return;

          setSelectedCardId(card.id);
          setGameState(WidgetState.REVEALING);

          try {
            const data = await getTarotReading(card.name);
            setReadingData(data);
            setTimeout(() => {
              setGameState(WidgetState.READING);
            }, 800); 
          } catch (e) {
            console.error(e);
          }
        }, [gameState]);

        const handleReset = () => {
          setGameState(WidgetState.IDLE);
          setSelectedCardId(null);
          setReadingData(null);
        };

        const getCardStyle = (index, total) => {
          const centerTransform = 'translate(-50%, -50%)';

          if (gameState === WidgetState.IDLE || gameState === WidgetState.SHUFFLING) {
             return {
               transform: `${centerTransform} translate(0px, 0px) rotate(0deg)`,
               zIndex: index,
               opacity: 1,
               transition: 'all 0.8s cubic-bezier(0.25, 0.8, 0.25, 1)',
               transformOrigin: 'center center'
             };
          }

          if (gameState === WidgetState.PICKING || gameState === WidgetState.REVEALING || gameState === WidgetState.READING) {
            const angle = (index - (total - 1) / 2) * 8;
            const xOffset = (index - (total - 1) / 2) * 35; 
            const yOffset = Math.abs(index - (total - 1) / 2) * 12; 

            if (selectedCardId !== null) {
              const isSelected = deck[index].id === selectedCardId;
              if (isSelected) {
                return {
                  transform: `${centerTransform} scale(1.2) rotate(0deg)`,
                  zIndex: 50,
                  opacity: 1,
                  transformOrigin: 'center center',
                  transition: 'all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275)'
                };
              } else {
                return {
                  transform: `${centerTransform} translate(${xOffset * 5}px, ${yOffset + 500}px) rotate(${angle * 2}deg)`,
                  opacity: 0,
                  zIndex: 0,
                  pointerEvents: 'none',
                  transformOrigin: 'center center',
                  transition: 'all 0.5s ease'
                };
              }
            }

            return {
              transform: `${centerTransform} translate(${xOffset}px, ${yOffset}px) rotate(${angle}deg)`,
              zIndex: index,
              opacity: 1,
              transformOrigin: 'bottom center',
              transition: 'all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)'
            };
          }
          
          return {};
        };

        return (
          <div className="relative w-full max-w-6xl mx-auto h-[600px] flex flex-col items-center justify-center overflow-hidden md:overflow-visible">
            <div className="absolute top-2 z-20 flex flex-col items-center pointer-events-none w-full">
              <img 
                src={LOGO_URL} 
                alt="Tarot & Tempest" 
                className="w-28 md:w-36 mb-1 drop-shadow-[0_0_10px_rgba(255,255,255,0.2)]"
              />
              <p className="text-white font-semibold text-[10px] md:text-xs tracking-[0.3em] uppercase animate-pulse mt-1 mix-blend-difference">
                {gameState === WidgetState.SHUFFLING && "INITIALIZING SEQUENCE..."}
                {gameState === WidgetState.PICKING && "SELECT YOUR FREQUENCY"}
                {gameState === WidgetState.REVEALING && "DECODING..."}
                {(gameState === WidgetState.IDLE) && "SYSTEM RESET..."}
              </p>
            </div>

            <div className="relative w-full h-full perspective-1000">
               {deck.map((card, index) => (
                 <div 
                   key={card.id}
                   className="absolute left-1/2 top-1/2 transition-all duration-500"
                   style={getCardStyle(index, deck.length)}
                 >
                   <Card 
                     card={card} 
                     isFlipped={selectedCardId === card.id}
                     onClick={() => handleCardClick(card)}
                     disabled={gameState !== WidgetState.PICKING}
                   />
                 </div>
               ))}
            </div>

            {gameState === WidgetState.READING && selectedCardId !== null && (
              <ReadingOverlay 
                card={deck.find(c => c.id === selectedCardId)} 
                readingData={readingData}
                onClose={handleReset}
              />
            )}
          </div>
        );
      };

      const App = () => {
        return (
          <div className="min-h-screen w-full bg-tempest-black flex items-center justify-center p-4">
            <div className="w-full max-w-7xl z-10">
              <MysteryWidget />
            </div>

            <div className="fixed bottom-4 right-4 text-tempest-gray text-xs font-bold tracking-widest uppercase opacity-50">
              Powered by Gemini â€¢ Tarot & Tempest
            </div>
          </div>
        );
      };

      const root = createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  </body>
</html>